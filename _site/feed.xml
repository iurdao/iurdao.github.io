<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-05-22T13:37:23+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Industry-University-Research Dao</title><subtitle>Industry-University-Research Dao in the Polkadot ecosystem</subtitle><author><name>Joe</name></author><entry><title type="html">CoreVM Engine</title><link href="http://localhost:4000/technics/2025/05/22/CoreVM-Engine.html" rel="alternate" type="text/html" title="CoreVM Engine" /><published>2025-05-22T00:00:00+08:00</published><updated>2025-05-22T00:00:00+08:00</updated><id>http://localhost:4000/technics/2025/05/22/CoreVM-Engine</id><content type="html" xml:base="http://localhost:4000/technics/2025/05/22/CoreVM-Engine.html"><![CDATA[<h1 id="corevm-engine">CoreVM Engine</h1>

<p>The Core VM Engine is the central execution system of PolkaVM, responsible for loading, compiling, and running guest programs in a secure and efficient manner. It provides the foundation for program execution, memory management, sandboxing, and interaction between host and guest code. For information about program representation, see <a href="https://deepwiki.com/paritytech/polkavm/4-program-representation">Program Representation</a>, and for the sandboxing system, see <a href="https://deepwiki.com/paritytech/polkavm/3-sandboxing">Sandboxing</a>.</p>

<h2 id="architecture-overview">Architecture Overview</h2>

<p>The Core VM Engine consists of several key components that work together to enable secure and efficient execution of programs.</p>

<p>Core VM Engine ArchitectureEngineModuleConfigurationRaw InstanceBackendInterpreter BackendCompiler BackendArchitecture-specific code generationSandbox implementationLinux SandboxGeneric Sandbox</p>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/api.rs#L96-L234">crates/polkavm/src/api.rs96-234</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/api.rs#L962-L2044">crates/polkavm/src/api.rs962-2044</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/lib.rs#L1-L172">crates/polkavm/src/lib.rs1-172</a></p>

<h2 id="key-components">Key Components</h2>

<h3 id="engine">Engine</h3>

<p>The <code class="language-plaintext highlighter-rouge">Engine</code> is the main entry point for using PolkaVM. It holds global state and configuration, and is responsible for creating new modules and managing sandbox workers.</p>

<p>Engine+selected_backend: BackendKind+selected_sandbox: Option&lt;SandboxKind&gt;+interpreter_enabled: bool+crosscheck: bool+state: Arc&lt;EngineState&gt;+allow_dynamic_paging: bool+allow_experimental: bool+new(config: \&amp;Config) : -&gt; Result&lt;Engine, Error&gt;+backend() : -&gt; BackendKind+idle_worker_pids() : -&gt; Vec&lt;u32&gt;«enumeration»BackendKindCompilerInterpreter«enumeration»SandboxKindLinuxGenericEngineState+sandboxing_enabled: bool+sandbox_global: Option&lt;GlobalStateKind&gt;+sandbox_cache: Option&lt;WorkerCacheKind&gt;+compiler_cache: CompilerCache+module_cache: ModuleCache</p>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/api.rs#L96-L234">crates/polkavm/src/api.rs96-234</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/config.rs#L7-L49">crates/polkavm/src/config.rs7-49</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/config.rs#L51-L85">crates/polkavm/src/config.rs51-85</a></p>

<h3 id="module">Module</h3>

<p>A <code class="language-plaintext highlighter-rouge">Module</code> represents a compiled program that can be instantiated for execution. It contains the program code, memory layout, and metadata about exports and imports.</p>

<p>Module+blob() : : \&amp;ProgramBlob+memory_map() : : \&amp;MemoryMap+default_sp() : : RegValue+exports() : : Iterator&lt;ProgramExport&gt;+imports() : : Imports+is_64_bit() : : bool+new(engine: \&amp;Engine, config: \&amp;ModuleConfig, bytes: ArcBytes) : -&gt; Result&lt;Module, Error&gt;+from_blob(engine: \&amp;Engine, config: \&amp;ModuleConfig, blob: ProgramBlob) : -&gt; Result&lt;Module, Error&gt;+instantiate() : -&gt; Result&lt;RawInstance, Error&gt;ModulePrivate+engine_state: Option&lt;Arc&lt;EngineState»+crosscheck: bool+blob: ProgramBlob+compiled_module: CompiledModuleKind+interpreted_module: Option&lt;InterpretedModule&gt;+memory_map: MemoryMap+gas_metering: Option&lt;GasMeteringKind&gt;+is_strict: bool+step_tracing: bool+dynamic_paging: bool+page_size_mask: u32+page_shift: u32+instruction_set: RuntimeInstructionSet+cost_model: CostModelRef</p>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/api.rs#L258-L780">crates/polkavm/src/api.rs258-780</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/api.rs#L386-L655">crates/polkavm/src/api.rs386-655</a></p>

<h3 id="rawinstance">RawInstance</h3>

<p>A <code class="language-plaintext highlighter-rouge">RawInstance</code> is an instantiated module that can be executed. It holds the execution state including registers, memory, and a pointer to the current instruction.</p>

<p>RawInstance+module: Module+backend: InstanceBackend+crosscheck_instance: Option&lt;Box&lt;InterpretedInstance»+module() : -&gt; \&amp;Module+is_64_bit() : -&gt; bool+run() : -&gt; Result&lt;InterruptKind, Error&gt;+reg(reg: Reg) : -&gt; RegValue+set_reg(reg: Reg, value: RegValue)+read_u8(address: u32) : -&gt; Result&lt;u8, MemoryAccessError&gt;+read_u16(address: u32) : -&gt; Result&lt;u16, MemoryAccessError&gt;+read_u32(address: u32) : -&gt; Result&lt;u32, MemoryAccessError&gt;+read_u64(address: u32) : -&gt; Result&lt;u64, MemoryAccessError&gt;+write_u8(address: u32, value: u8) -&gt; ResultUnsupported markdown: del+write_u16(address: u32, value: u16) -&gt; ResultUnsupported markdown: del+write_u32(address: u32, value: u32) -&gt; ResultUnsupported markdown: del+write_u64(address: u32, value: u64) -&gt; ResultUnsupported markdown: del«enumeration»InstanceBackendCompiledLinux(SandboxInstance&lt;SandboxLinux&gt;)CompiledGeneric(SandboxInstance&lt;SandboxGeneric&gt;)Interpreted(InterpretedInstance)</p>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/api.rs#L962-L2044">crates/polkavm/src/api.rs962-2044</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/api.rs#L859-L873">crates/polkavm/src/api.rs859-873</a></p>

<h2 id="execution-flow">Execution Flow</h2>

<p>The execution flow of the Core VM Engine encompasses program loading, instantiation, and the execution cycle.</p>

<p>“Execution Backend”“RawInstance”“Module”“Engine”“Host Program”“Execution Backend”“RawInstance”“Module”“Engine”“Host Program”alt[Normal Execution][Host Call][Error Condition]create(config)new module(blob)from_blob(engine, config, blob)ModuleModuleinstantiate()new(module)initializeRawInstanceset_reg(…)run()run()InterruptKind::FinishedInterruptKind::FinishedInterruptKind::Ecalli(n)InterruptKind::Ecalli(n)set_reg(…)run()InterruptKind::Trap/NotEnoughGas/SegfaultInterruptKind::Trap/NotEnoughGas/Segfault</p>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/api.rs#L386-L655">crates/polkavm/src/api.rs386-655</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/api.rs#L962-L2044">crates/polkavm/src/api.rs962-2044</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/utils.rs#L103-L139">crates/polkavm/src/utils.rs103-139</a></p>

<h3 id="instantiation-process">Instantiation Process</h3>

<p>When a module is instantiated:</p>

<ol>
  <li>The engine selects the appropriate backend (Compiler or Interpreter)</li>
  <li>If the Compiler backend is selected, the VM instructions are compiled to native code</li>
  <li>If sandboxing is enabled, a sandbox environment is prepared</li>
  <li>A RawInstance is created, linked to the appropriate backend</li>
  <li>Memory is allocated according to the module’s memory map</li>
</ol>

<h3 id="execution-cycle">Execution Cycle</h3>

<p>The execution cycle involves:</p>

<ol>
  <li>Setting up the initial state (registers, program counter)</li>
  <li>Running the code via the selected backend</li>
  <li>Handling interrupts that occur during execution</li>
  <li>Returning control to the host when necessary (for host calls or on completion)</li>
</ol>

<h3 id="interrupt-types">Interrupt Types</h3>

<p>The VM uses interrupts to handle various execution events:</p>

<table>
  <thead>
    <tr>
      <th>Interrupt Type</th>
      <th>Description</th>
      <th>Trigger</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Finished</td>
      <td>Normal termination</td>
      <td>Program jumps to <code class="language-plaintext highlighter-rouge">VM_ADDR_RETURN_TO_HOST</code></td>
    </tr>
    <tr>
      <td>Trap</td>
      <td>Abnormal termination</td>
      <td>Invalid instruction, jump, or explicit trap</td>
    </tr>
    <tr>
      <td>Ecalli</td>
      <td>Host function call</td>
      <td><code class="language-plaintext highlighter-rouge">ecalli</code> instruction executed</td>
    </tr>
    <tr>
      <td>NotEnoughGas</td>
      <td>Gas limit exceeded</td>
      <td>Gas counter reaches zero</td>
    </tr>
    <tr>
      <td>Segfault</td>
      <td>Memory access violation</td>
      <td>Accessing unmapped memory or writing to read-only memory</td>
    </tr>
    <tr>
      <td>Step</td>
      <td>Single step completed</td>
      <td>Step tracing is enabled</td>
    </tr>
  </tbody>
</table>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/utils.rs#L103-L139">crates/polkavm/src/utils.rs103-139</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/tests.rs#L365-L375">crates/polkavm/src/tests.rs365-375</a></p>

<h2 id="backends">Backends</h2>

<p>The Core VM Engine supports two execution backends:</p>

<h3 id="interpreter-backend">Interpreter Backend</h3>

<p>The Interpreter backend executes instructions one by one, interpreting each instruction as it runs. It’s implemented in <code class="language-plaintext highlighter-rouge">InterpretedInstance</code>:</p>

<p>InterpretedInstance+module: Module+basic_memory: BasicMemory+dynamic_memory: DynamicMemory+program_counter: ProgramCounter+program_counter_valid: bool+next_program_counter: Option&lt;ProgramCounter&gt;+next_program_counter_changed: bool+cycle_counter: u64+gas: i64+regs: [u64; Reg::ALL.len() : ]+new_from_module(module: Module, force_step_tracing: bool) : -&gt; Self+run() : -&gt; Result&lt;InterruptKind, Error&gt;+reg(reg: Reg) : -&gt; RegValue+set_reg(reg: Reg, value: RegValue)</p>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/interpreter.rs#L397-L752">crates/polkavm/src/interpreter.rs397-752</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/interpreter.rs#L1-L20">crates/polkavm/src/interpreter.rs1-20</a></p>

<h3 id="compiler-backend">Compiler Backend</h3>

<p>The Compiler backend translates the VM instructions to native machine code, which is executed directly by the CPU. This provides better performance but is more complex and requires platform-specific optimizations:</p>

<p>Compiler Backend FlowProgramBlobCompiler VisitorGas VisitorArchitecture VisitorGas Metering StubsNative Machine CodeCompiled ModuleSandbox Execution</p>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/api.rs#L237-L256">crates/polkavm/src/api.rs237-256</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/api.rs#L496-L575">crates/polkavm/src/api.rs496-575</a></p>

<h2 id="memory-management">Memory Management</h2>

<p>The VM has a well-defined memory layout to ensure security and proper isolation:</p>

<p>Memory LayoutVM Memory SpaceGuard PagesCode SectionRead-Only Data SectionRead-Write Data SectionStack RegionAuxiliary Data RegionHeap (via sbrk)</p>

<p>The memory layout is configured by the <code class="language-plaintext highlighter-rouge">MemoryMap</code> which defines the address ranges for each section:</p>

<table>
  <thead>
    <tr>
      <th>Section</th>
      <th>Purpose</th>
      <th>Access</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Code Section</td>
      <td>Contains executable instructions</td>
      <td>Read-only</td>
    </tr>
    <tr>
      <td>Read-Only Data</td>
      <td>Constants and immutable data</td>
      <td>Read-only</td>
    </tr>
    <tr>
      <td>Read-Write Data</td>
      <td>Global variables and mutable data</td>
      <td>Read-write</td>
    </tr>
    <tr>
      <td>Stack</td>
      <td>Function calls and local variables</td>
      <td>Read-write</td>
    </tr>
    <tr>
      <td>Auxiliary Data</td>
      <td>Host-configurable data region</td>
      <td>Read-write (from host)</td>
    </tr>
    <tr>
      <td>Heap</td>
      <td>Dynamically allocated memory</td>
      <td>Read-write</td>
    </tr>
  </tbody>
</table>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/api.rs#L594-L623">crates/polkavm/src/api.rs594-623</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/interpreter.rs#L79-L133">crates/polkavm/src/interpreter.rs79-133</a></p>

<h3 id="dynamic-paging">Dynamic Paging</h3>

<p>When enabled, dynamic paging allows memory to be mapped on-demand:</p>

<ol>
  <li>Pages are only allocated when accessed</li>
  <li>Attempting to access an unmapped page triggers a <code class="language-plaintext highlighter-rouge">Segfault</code> interrupt</li>
  <li>The host can map new pages or protect pages as needed</li>
  <li>Useful for memory-efficient execution of large programs</li>
</ol>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/interpreter.rs#L250-L282">crates/polkavm/src/interpreter.rs250-282</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/config.rs#L458-L471">crates/polkavm/src/config.rs458-471</a></p>

<h2 id="configuration">Configuration</h2>

<h3 id="engine-configuration">Engine Configuration</h3>

<p>The <code class="language-plaintext highlighter-rouge">Config</code> struct controls engine-level settings:</p>

<table>
  <thead>
    <tr>
      <th>Setting</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">backend</code></td>
      <td>Execution backend (Compiler/Interpreter)</td>
      <td>Best available</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sandbox</code></td>
      <td>Sandbox implementation (Linux/Generic)</td>
      <td>Best available</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">crosscheck</code></td>
      <td>Enable execution cross-checking</td>
      <td>false</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">allow_experimental</code></td>
      <td>Enable experimental features</td>
      <td>false</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">allow_dynamic_paging</code></td>
      <td>Enable dynamic paging</td>
      <td>false</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">worker_count</code></td>
      <td>Number of worker sandboxes</td>
      <td>2</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">cache_enabled</code></td>
      <td>Enable module caching</td>
      <td>true (with module-cache feature)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sandboxing_enabled</code></td>
      <td>Enable security sandboxing</td>
      <td>true</td>
    </tr>
  </tbody>
</table>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/config.rs#L100-L217">crates/polkavm/src/config.rs100-217</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/config.rs#L152-L366">crates/polkavm/src/config.rs152-366</a></p>

<h3 id="module-configuration">Module Configuration</h3>

<p>The <code class="language-plaintext highlighter-rouge">ModuleConfig</code> struct controls module-level settings:</p>

<table>
  <thead>
    <tr>
      <th>Setting</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">page_size</code></td>
      <td>Memory page size</td>
      <td>4096 (4K)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">gas_metering</code></td>
      <td>Gas metering type (None/Sync/Async)</td>
      <td>None</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">is_strict</code></td>
      <td>Enable strict mode for validation</td>
      <td>false</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">step_tracing</code></td>
      <td>Enable instruction-by-instruction tracing</td>
      <td>false</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">dynamic_paging</code></td>
      <td>Enable dynamic paging for this module</td>
      <td>false</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">aux_data_size</code></td>
      <td>Size of auxiliary data region</td>
      <td>0</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">allow_sbrk</code></td>
      <td>Allow dynamic heap allocation</td>
      <td>true</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">cost_model</code></td>
      <td>Gas cost model</td>
      <td>Naive cost model</td>
    </tr>
  </tbody>
</table>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/config.rs#L392-L583">crates/polkavm/src/config.rs392-583</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/config.rs#L413-L427">crates/polkavm/src/config.rs413-427</a></p>

<h2 id="gas-metering">Gas Metering</h2>

<p>Gas metering limits the computational resources a program can use:</p>

<p>Gas MeteringModule ConfigurationGas Metering KindSynchronousAsynchronousCheck after every instructionPeriodic checkingInterrupt: NotEnoughGas</p>

<h3 id="gas-metering-types">Gas Metering Types</h3>

<ul>
  <li><strong>Synchronous</strong>: Checks gas after every instruction. Precise but higher overhead.</li>
  <li><strong>Asynchronous</strong>: Checks gas periodically. Lower overhead but less precise timing of interruption.</li>
</ul>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/config.rs#L369-L385">crates/polkavm/src/config.rs369-385</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/api.rs#L361-L365">crates/polkavm/src/api.rs361-365</a></p>

<h2 id="security-considerations">Security Considerations</h2>

<h3 id="sandboxing">Sandboxing</h3>

<p>The Core VM Engine provides security through sandboxing:</p>

<ul>
  <li><strong>Linux Sandbox</strong>: Uses Linux-specific security features (seccomp, namespaces)</li>
  <li><strong>Generic Sandbox</strong>: Uses signal handlers for basic protection (less secure, considered experimental)</li>
</ul>

<h3 id="memory-protection">Memory Protection</h3>

<p>Memory protection ensures that:</p>

<ul>
  <li>Code and read-only data cannot be modified</li>
  <li>Out-of-bounds memory access is prevented</li>
  <li>Stack overflows are caught</li>
  <li>Guard pages isolate different memory regions</li>
</ul>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/api.rs#L153-L188">crates/polkavm/src/api.rs153-188</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/config.rs#L357-L366">crates/polkavm/src/config.rs357-366</a></p>

<h2 id="error-handling">Error Handling</h2>

<p>The VM uses a comprehensive error handling system:</p>

<ol>
  <li>The <code class="language-plaintext highlighter-rouge">Error</code> type encapsulates various error kinds</li>
  <li>The <code class="language-plaintext highlighter-rouge">InterruptKind</code> enum represents different types of execution interrupts</li>
  <li>The <code class="language-plaintext highlighter-rouge">MemoryAccessError</code> handles memory access failures</li>
</ol>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/error.rs#L19-L108">crates/polkavm/src/error.rs19-108</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/utils.rs#L103-L139">crates/polkavm/src/utils.rs103-139</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/api.rs#L876-L909">crates/polkavm/src/api.rs876-909</a></p>]]></content><author><name>Joe</name></author><category term="Technics" /><category term="CoreVM" /><category term="Engine" /><category term="JAM" /><category term="PolkaVM" /><summary type="html"><![CDATA[CoreVM Engine]]></summary></entry><entry><title type="html">PolkaVM Overview</title><link href="http://localhost:4000/technics/2025/05/22/Demystify-PolkaVM.html" rel="alternate" type="text/html" title="PolkaVM Overview" /><published>2025-05-22T00:00:00+08:00</published><updated>2025-05-22T00:00:00+08:00</updated><id>http://localhost:4000/technics/2025/05/22/Demystify-PolkaVM</id><content type="html" xml:base="http://localhost:4000/technics/2025/05/22/Demystify-PolkaVM.html"><![CDATA[<h1 id="polkavm-overview">PolkaVM Overview</h1>

<p>PolkaVM is a high-performance, sandboxed virtual machine designed to securely execute RISC-V programs. It serves as a lightweight and efficient execution environment with a strong focus on security, determinism, and performance. This page provides a high-level introduction to the PolkaVM system, its architecture, and key components.</p>

<p>For detailed information about the execution engine internals, see <a href="http://127.0.0.1:4000/technics/2025/05/22/CoreVM-Engine.html">Core VM Engine</a>. For information about the sandboxing mechanism, see <a href="https://deepwiki.com/paritytech/polkavm/3-sandboxing">Sandboxing</a>.</p>

<h2 id="purpose-and-goals">Purpose and Goals</h2>
<hr />

<p>PolkaVM aims to provide a secure, deterministic, and efficient execution environment for untrusted code. Its primary design goals include:</p>

<ol>
  <li><strong>Security</strong>: Isolate executing code using sandboxing techniques to prevent unauthorized system access</li>
  <li><strong>Performance</strong>: Offer high-speed execution through a JIT compiler backend when available</li>
  <li><strong>Determinism</strong>: Ensure consistent execution results regardless of the host environment</li>
  <li><strong>Resource Control</strong>: Limit resource consumption through gas metering</li>
  <li><strong>Portability</strong>: Run on various operating systems with platform-specific optimizations</li>
</ol>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/lib.rs#L1-L171">crates/polkavm/src/lib.rs1-171</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/Cargo.toml#L1-L202">Cargo.toml1-202</a></p>

<h2 id="system-architecture">System Architecture</h2>

<p>PolkaVM’s architecture consists of several key components that work together to provide a secure and efficient execution environment.</p>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/lib.rs#L1-L171">crates/polkavm/src/lib.rs1-171</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/Cargo.toml#L1-L202">Cargo.toml1-202</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/config.rs#L1-L534">crates/polkavm/src/config.rs1-534</a></p>

<h2 id="core-components">Core Components</h2>

<h3 id="engine">Engine</h3>

<p>The <code class="language-plaintext highlighter-rouge">Engine</code> is the central component of PolkaVM that manages the execution environment. It handles the creation of modules and provides configuration options for the VM.</p>

<p>Key features:</p>

<ul>
  <li>Backend selection (Compiler or Interpreter)</li>
  <li>Sandbox configuration</li>
  <li>Worker management</li>
  <li>Caching behavior</li>
</ul>

<p>Engine ConfigurationConfigBackendKindSandboxKindModuleConfigCompilerInterpreterLinuxGenericGasMeteringKind</p>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/config.rs#L1-L534">crates/polkavm/src/config.rs1-534</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/lib.rs#L139-L148">crates/polkavm/src/lib.rs139-148</a></p>

<h3 id="module-and-instance">Module and Instance</h3>

<p>The <code class="language-plaintext highlighter-rouge">Module</code> represents a compiled program ready for execution, while a <code class="language-plaintext highlighter-rouge">RawInstance</code> represents an active execution state.</p>

<ul>
  <li><strong>Module</strong>: Created from a <code class="language-plaintext highlighter-rouge">ProgramBlob</code>, contains the compiled code and metadata</li>
  <li><strong>RawInstance</strong>: Created from a <code class="language-plaintext highlighter-rouge">Module</code>, maintains the execution state including registers, memory, and gas counter</li>
</ul>

<p>The execution flow involves:</p>

<ol>
  <li>Creating a <code class="language-plaintext highlighter-rouge">Module</code> from a <code class="language-plaintext highlighter-rouge">ProgramBlob</code></li>
  <li>Instantiating a <code class="language-plaintext highlighter-rouge">RawInstance</code> from the <code class="language-plaintext highlighter-rouge">Module</code></li>
  <li>Running the instance, which produces an <code class="language-plaintext highlighter-rouge">InterruptKind</code> result</li>
</ol>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/lib.rs#L139-L148">crates/polkavm/src/lib.rs139-148</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/utils.rs#L93-L139">crates/polkavm/src/utils.rs93-139</a></p>

<h3 id="execution-backends">Execution Backends</h3>

<p>PolkaVM supports two execution backends:</p>

<ol>
  <li><strong>Compiler Backend</strong>: JIT-compiles the program to native code for high performance</li>
  <li><strong>Interpreter Backend</strong>: Interprets the program’s instructions directly, used as a fallback when compilation is not available</li>
</ol>

<p>The appropriate backend is selected based on platform support and configuration.</p>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/config.rs#L7-L49">crates/polkavm/src/config.rs7-49</a></p>

<h3 id="sandboxing">Sandboxing</h3>

<p>The sandbox component provides isolation for executing untrusted code, preventing it from accessing the host system directly:</p>

<ol>
  <li><strong>Linux Sandbox</strong>: Uses Linux-specific features like zygote processes, seccomp, and namespaces for efficient isolation</li>
  <li><strong>Generic Sandbox</strong>: A more portable implementation for other platforms</li>
</ol>

<p>Sandboxing SystemSandbox TraitLinux SandboxGeneric SandboxZygote ProcessLinux Security FeaturesseccompNamespacesuserfaultfdSignal Handlers</p>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/config.rs#L51-L98">crates/polkavm/src/config.rs51-98</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/.github/workflows/rust.yml#L1-L133">.github/workflows/rust.yml1-133</a></p>

<h3 id="program-representation">Program Representation</h3>

<p>Programs in PolkaVM are represented as a <code class="language-plaintext highlighter-rouge">ProgramBlob</code>, which contains:</p>

<ul>
  <li><strong>Code</strong>: The instructions to be executed</li>
  <li><strong>Read-Only Data</strong>: Constant data used by the program</li>
  <li><strong>Read-Write Data</strong>: Mutable data used by the program</li>
  <li><strong>Jump Table</strong>: Information for optimizing jumps in the code</li>
</ul>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/lib.rs#L117-L137">crates/polkavm/src/lib.rs117-137</a></p>

<h3 id="gas-metering">Gas Metering</h3>

<p>PolkaVM provides resource control through gas metering, allowing limits on how much computation a program can perform:</p>

<ol>
  <li><strong>Synchronous Gas Metering</strong>: Checks gas consumption after every instruction</li>
  <li><strong>Asynchronous Gas Metering</strong>: Periodically checks gas consumption for better performance</li>
</ol>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/config.rs#L369-L385">crates/polkavm/src/config.rs369-385</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/lib.rs#L139-L146">crates/polkavm/src/lib.rs139-146</a></p>

<h2 id="memory-management">Memory Management</h2>

<p>PolkaVM manages memory for guest programs using a structured memory layout:</p>

<p>Memory LayoutMemory MapGuard PagesCode SectionRead-only DataRead-write DataStackAuxiliary Data</p>

<p>The system supports dynamic paging, allowing memory to be mapped on-demand when accessed, which can improve performance for certain workloads.</p>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/utils.rs#L24-L44">crates/polkavm/src/utils.rs24-44</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/config.rs#L426-L447">crates/polkavm/src/config.rs426-447</a></p>

<h2 id="execution-flow">Execution Flow</h2>

<p>The execution of a program in PolkaVM follows this general flow:</p>

<p>“Sandbox”“RawInstance”“Module”“Engine”“Host Application”“Sandbox”“RawInstance”“Module”“Engine”“Host Application”For host calls (Ecalli)Create EngineCreate Module from ProgramBlobCompile/PrepareInstantiateCreateRunExecute in SandboxInterrupt (Finished/Trap/Ecalli/etc.)Return InterruptKindHandle host callResume executionContinue execution</p>

<p>When a program executes, it may be interrupted for various reasons, represented by the <code class="language-plaintext highlighter-rouge">InterruptKind</code> enum:</p>

<ul>
  <li><strong>Finished</strong>: The program completed execution normally</li>
  <li><strong>Trap</strong>: The program encountered an error or invalid operation</li>
  <li><strong>Ecalli</strong>: The program is calling out to a host function</li>
  <li><strong>Segfault</strong>: The program attempted an invalid memory access</li>
  <li><strong>NotEnoughGas</strong>: The program ran out of its gas allocation</li>
  <li><strong>Step</strong>: Returned when step tracing is enabled, after each instruction</li>
</ul>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/utils.rs#L93-L139">crates/polkavm/src/utils.rs93-139</a></p>

<h2 id="tools-and-utilities">Tools and Utilities</h2>

<p>PolkaVM provides several tools for working with programs:</p>

<ol>
  <li><strong>polkatool</strong>: Command-line utility for linking, assembling, disassembling and analyzing PolkaVM programs</li>
  <li><strong>benchtool</strong>: Benchmarking tool for comparing PolkaVM with other VMs</li>
  <li><strong>spectool</strong>: Test case generation and execution tool</li>
</ol>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/Cargo.toml#L1-L202">Cargo.toml1-202</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/tools/benchtool/Cargo.lock#L1-L5358">tools/benchtool/Cargo.lock1-5358</a></p>

<h2 id="configuration-options">Configuration Options</h2>

<p>PolkaVM can be configured through a variety of options in the <code class="language-plaintext highlighter-rouge">Config</code> and <code class="language-plaintext highlighter-rouge">ModuleConfig</code> structs:</p>

<table>
  <thead>
    <tr>
      <th>Configuration</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Backend</td>
      <td>Execution backend (Compiler/Interpreter)</td>
      <td>Auto-detect</td>
    </tr>
    <tr>
      <td>Sandbox</td>
      <td>Sandboxing mechanism (Linux/Generic)</td>
      <td>Auto-detect</td>
    </tr>
    <tr>
      <td>Gas Metering</td>
      <td>Resource control method (Sync/Async/None)</td>
      <td>None</td>
    </tr>
    <tr>
      <td>Worker Count</td>
      <td>Number of worker sandboxes to keep alive</td>
      <td>2</td>
    </tr>
    <tr>
      <td>Dynamic Paging</td>
      <td>Enable on-demand memory mapping</td>
      <td>False</td>
    </tr>
    <tr>
      <td>Cache Enabled</td>
      <td>Enable module caching</td>
      <td>True with module-cache feature</td>
    </tr>
    <tr>
      <td>Sandboxing Enabled</td>
      <td>Enable security sandboxing</td>
      <td>True</td>
    </tr>
    <tr>
      <td>Page Size</td>
      <td>Size of memory pages</td>
      <td>4096 (4KB)</td>
    </tr>
    <tr>
      <td>Step Tracing</td>
      <td>Enable instruction-by-instruction tracing</td>
      <td>False</td>
    </tr>
  </tbody>
</table>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/config.rs#L100-L367">crates/polkavm/src/config.rs100-367</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/config.rs#L392-L534">crates/polkavm/src/config.rs392-534</a></p>

<h2 id="platform-support">Platform Support</h2>

<p>PolkaVM primarily targets the following platforms:</p>

<ul>
  <li><strong>Linux</strong> (x86_64): Full support with the compiler backend and Linux-specific sandboxing</li>
  <li><strong>macOS</strong> (x86_64): Support with the generic sandbox when the feature is enabled</li>
  <li><strong>FreeBSD</strong> (x86_64): Support with the generic sandbox when the feature is enabled</li>
  <li><strong>Windows</strong> (x86_64): Limited support</li>
</ul>

<p>The compiler backend is only available on x86_64 architecture, while the interpreter backend works across all supported platforms.</p>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/.github/workflows/rust.yml#L1-L133">.github/workflows/rust.yml1-133</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/lib.rs#L9-L51">crates/polkavm/src/lib.rs9-51</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/ci/jobs/check-freebsd.sh#L1-L11">ci/jobs/check-freebsd.sh1-11</a></p>

<h2 id="system-requirements">System Requirements</h2>

<p>For optimal performance with the Linux sandbox and dynamic paging:</p>

<ul>
  <li>Linux 6.7+ kernel</li>
  <li>Unprivileged userfaultfd must be enabled (<code class="language-plaintext highlighter-rouge">/proc/sys/vm/unprivileged_userfaultfd</code> must be set to <code class="language-plaintext highlighter-rouge">1</code>)</li>
  <li>For some features, unprivileged user namespaces must be allowed</li>
</ul>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/config.rs#L299-L308">crates/polkavm/src/config.rs299-308</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/.github/workflows/rust.yml#L1-L133">.github/workflows/rust.yml1-133</a></p>]]></content><author><name>Joe</name></author><category term="Technics" /><category term="JAM" /><category term="PolkaVM" /><summary type="html"><![CDATA[PolkaVM Overview]]></summary></entry><entry><title type="html">Sandboxing</title><link href="http://localhost:4000/technics/2025/05/22/Sandboxing.html" rel="alternate" type="text/html" title="Sandboxing" /><published>2025-05-22T00:00:00+08:00</published><updated>2025-05-22T00:00:00+08:00</updated><id>http://localhost:4000/technics/2025/05/22/Sandboxing</id><content type="html" xml:base="http://localhost:4000/technics/2025/05/22/Sandboxing.html"><![CDATA[<h1 id="sandboxing">Sandboxing</h1>

<p>Sandboxing is a critical security feature in PolkaVM that isolates guest program execution from the host system. This isolation is essential for preventing malicious or erroneous code from affecting the host environment or accessing unauthorized resources. This document explains how PolkaVM implements sandboxing, the different sandbox implementations available, and the security mechanisms they employ.</p>

<p>For information about how program code is executed within the sandbox, see <a href="https://deepwiki.com/paritytech/polkavm/2-core-vm-engine">Core VM Engine</a> and <a href="https://deepwiki.com/paritytech/polkavm/2.3-execution-flow">Execution Flow</a>.</p>

<h2 id="sandbox-architecture-overview">Sandbox Architecture Overview</h2>

<p>PolkaVM implements a trait-based architecture for sandboxing, with specialized implementations for different operating systems. The system is designed to be extensible while providing secure isolation guarantees.</p>

<p>ImplementationsSandbox InterfaceSandbox TraitSandboxConfig TraitSandboxProgram TraitLinux SandboxGeneric SandboxLinux SandboxConfigGeneric SandboxConfigLinux SandboxProgramGeneric SandboxProgramZygote Process ModelLinux Security FeaturesNamespacesSeccomp FiltersResource LimitsUserfaultfd (Dynamic Paging)Signal HandlersMemory Isolation</p>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/sandbox.rs#L88-L138">crates/polkavm/src/sandbox.rs88-138</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/sandbox/linux.rs#L37-L192">crates/polkavm/src/sandbox/linux.rs37-192</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/sandbox/generic.rs#L92-L139">crates/polkavm/src/sandbox/generic.rs92-139</a></p>

<h2 id="sandbox-interface">Sandbox Interface</h2>

<p>The <code class="language-plaintext highlighter-rouge">Sandbox</code> trait defines a common interface for all sandbox implementations. It specifies methods for:</p>

<ul>
  <li>Creating and managing sandbox instances</li>
  <li>Loading compiled modules</li>
  <li>Executing code within the sandbox</li>
  <li>Accessing and manipulating memory and registers</li>
  <li>Handling interrupts and traps</li>
</ul>

<p>The trait ensures that different sandboxing implementations can be used interchangeably while providing the same level of functionality.</p>

<p>ContainsManages«trait»Sandbox+KIND: SandboxKind+spawn() : Result&lt;Self, Error&gt;+load_module() ResultUnsupported markdown: del+run() : Result&lt;InterruptKind, Error&gt;+reg(reg: Reg) : RegValue+set_reg(reg: Reg, value: RegValue)+gas() : Gas+set_gas(gas: Gas)+program_counter() : Option&lt;ProgramCounter&gt;+read_memory_into() : Result&lt;&amp;[u8], MemoryAccessError&gt;+write_memory() ResultUnsupported markdown: del+heap_size() : u32+sbrk(size: u32) : Result&lt;OptionUnsupported markdown: delSandboxInstance-engine_state: Arc&lt;EngineState&gt;-sandbox: Option&lt;S&gt;+spawn_and_load_module() : Result&lt;Self, Error&gt;WorkerCache-sandboxes: Mutex&lt;Vec&lt;S»-available_workers: AtomicUsize-worker_limit: usize+spawn() ResultUnsupported markdown: del+reuse_sandbox() : Option&lt;S&gt;+recycle_sandbox()LinuxSandboxGenericSandbox</p>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/sandbox.rs#L88-L138">crates/polkavm/src/sandbox.rs88-138</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/sandbox.rs#L152-L223">crates/polkavm/src/sandbox.rs152-223</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/sandbox.rs#L321-L424">crates/polkavm/src/sandbox.rs321-424</a></p>

<h2 id="linux-sandbox-implementation">Linux Sandbox Implementation</h2>

<p>The Linux sandbox implementation leverages the advanced security features available in the Linux kernel to provide strong isolation guarantees.</p>

<h3 id="zygote-process-model">Zygote Process Model</h3>

<p>The Linux sandbox uses a “zygote” process model, where a master process (the zygote) is forked to create child processes that execute guest code. This approach allows for:</p>

<ol>
  <li>Fast creation of new sandbox instances</li>
  <li>Strong process-level isolation</li>
  <li>Efficient resource management</li>
</ol>

<p>“Child Sandbox Process”“Zygote Process”“GlobalState”“Host Process”“Child Sandbox Process”“Zygote Process”“GlobalState”“Host Process”Sandbox can be recycled for future usenew(config)prepare_zygote()zygote_memfdclone(SANDBOX_FLAGS)spawn()fork from zygotesend shared memory descriptorsset up signal handlersset up seccomp filtersload_module(module)run()return interrupt</p>

<p>The zygote process is created with a carefully controlled environment, and when a new sandbox is needed, the zygote is forked to create a new process. This new process inherits the initialized state but runs with its own memory space and restricted permissions.</p>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/sandbox/linux.rs#L150-L179">crates/polkavm/src/sandbox/linux.rs150-179</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/sandbox/linux.rs#L644-L672">crates/polkavm/src/sandbox/linux.rs644-672</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/sandbox/linux.rs#L739-L799">crates/polkavm/src/sandbox/linux.rs739-799</a></p>

<h3 id="security-mechanisms">Security Mechanisms</h3>

<p>The Linux sandbox employs multiple security mechanisms to provide isolation:</p>

<ol>
  <li><strong>Namespaces</strong>: The sandbox uses Linux namespaces (<code class="language-plaintext highlighter-rouge">CLONE_NEWCGROUP</code>, <code class="language-plaintext highlighter-rouge">CLONE_NEWIPC</code>, <code class="language-plaintext highlighter-rouge">CLONE_NEWNET</code>, etc.) to isolate the process from the host system’s resources.</li>
  <li><strong>Seccomp Filters</strong>: A seccomp filter is applied to restrict the system calls that the sandboxed process can make. This limits the potential attack surface.</li>
  <li><strong>Resource Limits</strong>: Resource limits are set on the sandboxed process to prevent it from consuming excessive resources.</li>
  <li><strong>Capability Restrictions</strong>: All capabilities are dropped from the sandboxed process, ensuring it can’t perform privileged operations.</li>
  <li><strong>Filesystem Isolation</strong>: The filesystem is completely hidden from the sandboxed process using <code class="language-plaintext highlighter-rouge">pivot_root</code> and <code class="language-plaintext highlighter-rouge">umount2</code>.</li>
</ol>

<p>Sandbox Security MechanismsLinux NamespacesCLONE_NEWCGROUPCLONE_NEWIPCCLONE_NEWNETCLONE_NEWNSCLONE_NEWPIDCLONE_NEWUSERCLONE_NEWUTSSeccomp FiltersAllowed Syscallsfutexmmap (restricted)munmapmadvise (MADV_DONTNEED only)closert_sigreturnsched_yieldexitmprotect (restricted)Resource LimitsRLIMIT_DATA: 8 GBRLIMIT_STACK: 16 KBRLIMIT_NPROC: 1RLIMIT_FSIZE: 0RLIMIT_LOCKS: 0RLIMIT_MEMLOCK: 0RLIMIT_MSGQUEUE: 0RLIMIT_NOFILE: 0Capability RestrictionsSECBIT_NOROOTSECBIT_NO_SETUID_FIXUPSECBIT_NO_CAP_AMBIENT_RAISEcapset_drop_all()</p>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/sandbox/linux.rs#L47-L53">crates/polkavm/src/sandbox/linux.rs47-53</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/sandbox/linux.rs#L747-L795">crates/polkavm/src/sandbox/linux.rs747-795</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/sandbox/linux.rs#L857-L878">crates/polkavm/src/sandbox/linux.rs857-878</a></p>

<h2 id="memory-protection-and-isolation">Memory Protection and Isolation</h2>

<p>Memory protection is a key aspect of sandboxing in PolkaVM. The system ensures that guest programs can only access memory regions they’re allowed to, preventing unauthorized access to host memory or memory belonging to other guests.</p>

<h3 id="memory-layout">Memory Layout</h3>

<p>PolkaVM uses a carefully designed memory layout with different regions for code, data, and control structures.</p>

<p>Memory Protection MechanismsVirtual Memory LayoutGuest Memory Regions (0x0-0xFFFFFFFF)Host-only RegionsVM_ADDR_NATIVE_CODE (0x100000000)VM_ADDR_JUMP_TABLE (0x800000000)VM_ADDR_VMCTX (0x400000000)VM_ADDR_SIGSTACK (0x500000000)VM_ADDR_NATIVE_STACK (0x600000000)Guest CodeGuest Read-only DataGuest Read-write DataGuest StackGuest Heap (Dynamically Grown)VM_ADDR_SHARED_MEMORY (0x700000000)Memory Permission MappingMemory Mapping ControlDynamic Paging (userfaultfd)Signal Handling for Access Violations</p>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm-common/src/zygote.rs#L87-L120">crates/polkavm-common/src/zygote.rs87-120</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/sandbox/linux.rs#L913-L921">crates/polkavm/src/sandbox/linux.rs913-921</a></p>

<h3 id="dynamic-paging">Dynamic Paging</h3>

<p>On Linux systems with kernel 6.8 or newer, PolkaVM can use <code class="language-plaintext highlighter-rouge">userfaultfd</code> for dynamic paging. This allows memory to be mapped on-demand when accessed, leading to more efficient memory usage. When a page fault occurs, the host can handle it and potentially map the required memory.</p>

<p>“Linux Kernel”“Host Process”“VM Runtime”“Guest Code”“Linux Kernel”“Host Process”“VM Runtime”“Guest Code”Access unmapped memoryPage faultuserfaultfd notificationHandle page faultMap memory pageResume executionContinue with memory access</p>

<p>Dynamic paging is particularly useful for efficiently implementing the guest heap, which can grow as needed without pre-allocating large amounts of memory.</p>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/sandbox/linux.rs#L98-L149">crates/polkavm/src/sandbox/linux.rs98-149</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/sandbox/linux.rs#L594-L610">crates/polkavm/src/sandbox/linux.rs594-610</a></p>

<h3 id="memory-access-control">Memory Access Control</h3>

<p>Memory access control is enforced through multiple mechanisms:</p>

<ol>
  <li><strong>Memory Mapping</strong>: Memory regions are mapped with specific permissions (read, write, execute).</li>
  <li><strong>Page Protection</strong>: The <code class="language-plaintext highlighter-rouge">mprotect</code> system call is used to change permissions on memory regions.</li>
  <li><strong>Signal Handling</strong>: Attempts to access memory with insufficient permissions trigger signals (SIGSEGV, SIGBUS) that are caught and handled.</li>
  <li><strong>Explicit Permission Checks</strong>: The sandbox API includes methods to check if memory regions are accessible.</li>
</ol>

<p>When a memory access violation occurs, it’s converted into a clean trap that the host can handle, rather than crashing the entire process.</p>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/sandbox/linux.rs#L1066-L1092">crates/polkavm/src/sandbox/linux.rs1066-1092</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/sandbox/linux.rs#L2282-L2364">crates/polkavm/src/sandbox/linux.rs2282-2364</a></p>

<h2 id="communication-between-host-and-sandbox">Communication Between Host and Sandbox</h2>

<p>Communication between the host and sandbox processes happens primarily through shared memory, with additional synchronization mechanisms.</p>

<p>Sandbox ProcessHost ProcessSharedMemoryFutexSignalPipeUserfaultFDCommunication MechanismsShared MemoryFutex SynchronizationSignal Pipeuserfaultfd (Dynamic Paging)EngineRawInstanceVmCtx (Shared Memory)VmCtx (Shared Memory)Guest ProgramSignal Handlers</p>

<p>The <code class="language-plaintext highlighter-rouge">VmCtx</code> structure is mapped into shared memory accessible by both the host and sandbox processes. It contains:</p>

<ol>
  <li><strong>Registers</strong>: The state of the virtual machine’s registers</li>
  <li><strong>Gas Counter</strong>: For metering resource usage</li>
  <li><strong>Program Counters</strong>: Tracking execution position</li>
  <li><strong>Futex</strong>: For synchronization between host and sandbox</li>
  <li><strong>Heap Information</strong>: Managing the heap state</li>
  <li><strong>Message Buffer</strong>: For error reporting</li>
</ol>

<p>The host and sandbox use futex operations to synchronize state transitions, such as when the sandbox is idle, executing, or has encountered an interrupt.</p>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm-common/src/zygote.rs#L139-L408">crates/polkavm-common/src/zygote.rs139-408</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/sandbox/linux.rs#L1063-L1061">crates/polkavm/src/sandbox/linux.rs1063-1061</a></p>

<h2 id="sandbox-lifecycle-management">Sandbox Lifecycle Management</h2>

<p>Sandbox instances in PolkaVM are managed efficiently to minimize the overhead of creating new sandboxes.</p>

<h3 id="worker-cache">Worker Cache</h3>

<p>The <code class="language-plaintext highlighter-rouge">WorkerCache</code> component allows for efficient reuse of sandbox instances. Instead of destroying a sandbox after use, it can be returned to a pool for later reuse. This significantly reduces the overhead of creating new sandboxes, especially on Linux where fork operations and security setup are expensive.</p>

<p>The worker cache maintains a pool of idle sandbox instances up to a configurable limit. When a new sandbox is needed, an idle one can be reused from the pool if available.</p>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/sandbox.rs#L321-L424">crates/polkavm/src/sandbox.rs321-424</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/sandbox/linux.rs#L4124-L4187">crates/polkavm/src/sandbox/linux.rs4124-4187</a></p>

<h2 id="error-handling-and-traps">Error Handling and Traps</h2>

<p>PolkaVM handles errors and exceptions that occur during sandbox execution through a trap mechanism.</p>

<h3 id="interrupt-kinds">Interrupt Kinds</h3>

<p>When a sandbox’s execution is interrupted, the reason is represented by an <code class="language-plaintext highlighter-rouge">InterruptKind</code> enum:</p>

<ol>
  <li><strong>Finished</strong>: The program has completed execution normally</li>
  <li><strong>Trap</strong>: A trap (e.g., division by zero) has occurred</li>
  <li><strong>Ecalli</strong>: A host call has been requested</li>
  <li><strong>NotEnoughGas</strong>: The gas limit has been exceeded</li>
  <li><strong>Segfault</strong>: A memory access violation has occurred</li>
</ol>

<p>Host HandlingGuest Program ExecutionNormal ExecutionProgram TerminationInvalid OperationHost CallGas Limit ExceededMemory ViolationExecute InstructionInterruptKind::FinishedInterruptKind::TrapInterruptKind::EcalliInterruptKind::NotEnoughGasInterruptKind::SegfaultProcess ResultHandle TrapProcess Host CallAbort ExecutionHandle Memory Access Violation</p>

<h3 id="signal-handling">Signal Handling</h3>

<p>On Linux, signals like SIGSEGV (segmentation fault), SIGBUS (bus error), and SIGILL (illegal instruction) are caught by a signal handler. The handler analyzes the signal, captures the program state, and communicates the issue back to the host through the shared <code class="language-plaintext highlighter-rouge">VmCtx</code>.</p>

<p>For example, when a page fault occurs due to accessing unmapped memory, the signal handler captures the fault address and notifies the host, which can then handle it appropriately (e.g., by mapping the required memory if it’s part of the heap).</p>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/sandbox/linux.rs#L293-L421">crates/polkavm/src/sandbox/linux.rs293-421</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm-zygote/src/main.rs#L293-L408">crates/polkavm-zygote/src/main.rs293-408</a></p>

<h2 id="generic-sandbox-implementation">Generic Sandbox Implementation</h2>

<p>In addition to the Linux-specific sandbox, PolkaVM provides a generic sandbox implementation that works on other platforms. This implementation uses more portable mechanisms but may offer fewer isolation guarantees.</p>

<p>The generic sandbox uses:</p>

<ol>
  <li>Signal handlers for catching traps and memory violations</li>
  <li>Memory mapping with protection for isolation</li>
  <li>Position-independent execution with controlled entry and exit points</li>
</ol>

<p>While the generic sandbox doesn’t provide process-level isolation, it still ensures that guest programs can’t access unauthorized memory or execute unauthorized operations.</p>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/sandbox/generic.rs#L92-L139">crates/polkavm/src/sandbox/generic.rs92-139</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/sandbox/generic.rs#L292-L362">crates/polkavm/src/sandbox/generic.rs292-362</a></p>

<h2 id="security-considerations">Security Considerations</h2>

<p>When using PolkaVM’s sandboxing capabilities, consider the following:</p>

<ol>
  <li><strong>Isolation Strength</strong>: The Linux sandbox provides stronger isolation guarantees than the generic sandbox.</li>
  <li><strong>Kernel Requirements</strong>: For full functionality on Linux, a kernel version 6.8 or newer is recommended for dynamic paging support.</li>
  <li><strong>Resource Limits</strong>: Configure appropriate gas limits to prevent infinite loops or excessive resource consumption.</li>
  <li><strong>Host Function Exposure</strong>: Be cautious about which host functions you expose to guest programs, as they represent entry points back into the host environment.</li>
</ol>

<p>The sandboxing system is designed with security as a primary goal, but no sandboxing solution can provide absolute guarantees. Use defense in depth and carefully consider what capabilities you expose to guest programs.</p>

<p>Sources: <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/sandbox/linux.rs#L98-L149">crates/polkavm/src/sandbox/linux.rs98-149</a> <a href="https://github.com/paritytech/polkavm/blob/910adbda/crates/polkavm/src/sandbox.rs#L427-L428">crates/polkavm/src/sandbox.rs427-428</a></p>

<h2 id="summary">Summary</h2>

<p>PolkaVM’s sandboxing system provides strong isolation for executing untrusted code. The Linux sandbox implementation offers robust process-level isolation using advanced kernel features, while the generic sandbox provides a more portable option with memory-level isolation.</p>

<p>The system is designed to be efficient, with features like worker caching to minimize overhead, and secure, with multiple layers of protection to prevent unauthorized access and resource abuse.</p>

<p>For developers integrating PolkaVM, understanding the sandboxing mechanisms is crucial for building secure applications that can safely execute untrusted code.</p>]]></content><author><name>Joe</name></author><category term="Technics" /><category term="JAM" /><category term="PolkaVM" /><category term="Sandboxing" /><summary type="html"><![CDATA[Sandboxing]]></summary></entry></feed>